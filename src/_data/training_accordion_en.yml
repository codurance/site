panels:
  - id: why-attend
    title: Why Attend?
    content: training_content_why_attend.liquid
  - id: audience
    title: Audience
    content: training_content_audience.liquid
  - id: course-content
    title: Course Content
    content: training_content_course_content.liquid
  - id: prerequisites
    title: Prerequisites
    content: training_content_prerequisites.liquid

crafting-code-and-crafted-design:
  why-attend:
    intro: Software Craftsmanship is at the heart of this course. Throughout this training series, your team will learn about the Software Craftsmanship mindset and how to apply it within your organisation.
    clean-code-headline-one: Writing Clean Code is difficult. Cleaning existing code, even more so.
    why-attend: "Your team should attend if you need them to:"
    why-attend-list:
      - Align technology to business requirements
      - Write clean code that is easy to understand, maintain, and adapt
      - "Become more proficient in Test-Driven Development (TDD): using tests to design and build"
    clean-code-headline-two: Clean code necessitates good design.
    learning-objectives-title: "Your team will learn how to:"
    learning-objectives-list:
      - Understand design principles that lead to clean code
      - Avoid over-engineering and large rewrites by incrementally evolving design using tests
    learning-outcome: Once your team has mastered their understanding of these principles, they will apply them to legacy code. This will allow them to gain confidence working with legacy code.
    software-design-intro: The software design portion of this training series focuses on the application and microservices levels using business requirements to drive design making. Many of the design discussions during the exercises are focused on real-world scenarios that can be implemented in your organisation.
    application-title: "Application:"
    application-list:
      - internal structure
      - layers
      - components
      - delivery mechanism
      - core domain
    microservices-title: "Microservices:"
    microservices-list:
      - define the responsibility of each service
      - how services collaborate
      - internal/external visibility

  audience:
    intro: "This course is designed for software development teams that:"
    list:
      - are familiar with a minimum of one Object-Oriented language
      - are able to understand Java or C#
      - are able to write and execute unit tests using a framework (such as JUnit, NUnit, etc.)
      - have a basic understanding of mock objects

  course-content:
    principles-intro: "Principles of:"
    list:
      - Test-Driven Development (TDD)
      - Object-Oriented Design (OOD)
      - Domain-Driven Design (DDD)
      - Interaction-Driven Design (IDD)
    content-intro: "Content:"
    second-list:
      - TDD lifecycle and modelling behaviors
      - Writing unit tests that express intent, not implementation
      - Using unit tests to drive good design
      - Expressive code
      - Testing and refactoring legacy code
      - How to structure projects so that it expresses what the application does and what it is about
      - Understanding the differences between layers, hexagons, features, and components
      - Identifying services from business rules
      - Express design and architecture in code, but keeping your domain clear
      - Understanding Impact Mapping and how a services architecture can be derived from it

  prerequisites:
    intro: The is a hands on training course. Software development teams will be required to write a lot of code.
    required: "Required:"
    list:
      - Bring their own laptop
      - Be able to create projects, build source code, and run test cases in their development environment
      - "Have a development environment that consists of the following:"
      - A distributed version-control system such as Github is preferable
    second-list:
      - Object-Oriented language
      - A unit test framework
      - A mocking library


crafting-code:
  why-attend:
    intro: Software Craftsmanship is at the heart of this course. Throughout this training series, your team will learn about the Software Craftsmanship mindset and how to apply it within your organisation.
    clean-code-headline-one: Writing Clean Code is difficult. Cleaning existing code, even more so.
    why-attend: "Your team should attend if they need to:"
    why-attend-list:
      - Write clean code that is easy to understand, maintain, and adapt
      - "Become more proficient in Test-Driven Development (TDD): using tests to design and build"
      - "Through practical exercises, learn the difference between the two most important TDD styles: Chicago school (classicist) and London School (outside-in)."
      - Learn how to define test boundaries and responsibilities.
      - How do we define a unit?
      - What is the difference between the test boundary and test responsibility?
      - What should we mock? What should not be mocked?
      - Learn how to write tests that express business behaviour, not technical implementation.
      - Learn how to test and refactor legacy code
      - How to deal with hard-wired dependencies
      - How to localise tests while avoiding a major refactor of the code
      - Refactor the code to express business rules
    clean-code-headline-two: Clean code demands good design.
    learning-objectives-title: "Your team will learn how to:"
    learning-objectives-list:
      - Design code that expresses business requirements.
      - Understand design principles that lead to clean code
      - Pay attention to every minor detail at code level, like names, responsibilities of classes and methods, types,
      - Look closely at the key principles of design like coupling and cohesion and how they are applied at code level.
      - Avoid over-engineering and large rewrites by incrementally evolving the software design through testing
    learning-outcome: Software Craftsmanship is a mindset that focuses on professionalism and quality. Clean Code and Test-Driven Development are part of that mindset and are at the heart of this course. More than learning the techniques, the course also touches on the attitude expected from professional software developers.

  audience:
    intro: "This course is designed for software development teams that are:"
    list:
      - Fluent with at least one Object-Oriented language, such as Java, C#, or C++
      - Able to understand Java or C#
      - Able to write and execute unit tests using a framework, such as JUnit, NUnit, etc.
      - Have a basic understanding of mock objects
    note: "Note: this is not a course for people who are learning how to code. Developers with a few years in the industry will benefit more from this course then people with limited industry experience. Also, this is not a basic TDD training. This course is fully hands-on and fast-paced. Although the course can be attended and followed by developers without TDD experience, people with TDD experience will benefit more from it."

  course-content:
    principles-intro: "Principles of:"
    list:
      - Test-Driven Development (TDD)
      - Object-Oriented Design (OOO)
      - Domain-Driven Design (DDD)
    content-intro: "Content:"
    second-list:
      - Advanced introduction to TDD lifecycle
      - Chicago School (classicist) TDD
      - London School (Outside-In) TDD
      - Expressing business behaviour via tests, not implementation
      - Principles of Clean Code and good design
      - Using unit tests as a tool to drive good design
      - Mocking as a design tool
      - Expressive code that describes business rules
      - Testing and refactoring legacy code

  prerequisites:
    intro: This is a fast-paced and hands-on training course. Software development teams will be required to write a lot of code.
    required: "Required:"
    list:
      - Bringing their own laptop
      - Being able to create projects from scratch, adding test and mocking libraries, building source code, and runing test cases in their development environment
      - "Having a development environment that consists of the following:"
      - A distributed version control system such as git (optional)
    second-list:
      - Object-Oriented language
      - A unit test framework
      - A mocking library


crafted-design:
  why-attend:
    intro: This course addresses design from a micro level through to microservices utilising Test-Driven Development. The course teaches teams how to design software that is both responsive to changing requirements and new functionally, while avoiding some of the pitfalls that lead to legacy code.
    learning-objectives-title: "This course teaches software development teams how to:"
    learning-objectives-list:
      - Design techniques that can be applied to real-world situations
      - Derive a microservices architecture from business requirements
      - Maintain clean design as the application grows and business requirements change
      - Build software that is technology agnostic

  audience:
    intro: "This course is designed for software development teams that:"
    list:
      - Have at least two years of commercial software development experience
      - Familiar with a minimum of one Object-Oriented language, such as Java, C#, or C++
      - Comfortable using TDD to build software
      - Understand mock objects and how to use a mocking library
      - Have a general understanding of different architectural styles, including microservices

  course-content:
    principles-intro: "Principles of:"
    list:
      - The two main styles of Test-Driven Design (Classicist and Outside-In)
      - Object-Oriented Design (OOO)
      - Domain-Driven Design (DDD)
      - Interaction-Driven Design (IDD)
      - Balanced Abstraction Principle (BAP)
    content-intro: "Content:"
    second-list:
      - Writing unit tests that express intent, not implementation
      - Emergent design through classicist TDD
      - Using TDD as a design tool with the Outside-In style of TDD
      - Commands, Queries, and Open/Close Principle compliance
      - Differences between layers, hexagons, features, and components
      - Structure projects in a way that express what the application does and what it is about
      - Modeling behaviour using Outside-In Design
      - Identifying services from business rules
      - Expressive design and architecture in code, but keeping your domain clear
      - Understanding Impact Mapping and how a services architecture can be derived from it

  prerequisites:
    intro: We strongly recommend that software development teams take <a href="/services/training/crafting-code/" target="_blank">Crafting Code</a> before attempting this course. This is not an introductory Test-Driven Development course, and those users without a solid understanding may struggle with the material.
    required: "Required:"
    list:
      - Bring their own laptop
      - Using TDD regularly on projects
      - Able to create projects, tests, and code and run them in their local environment
      - A distributed version-control system such as Github is preferable


functional-programming:
  why-attend:
    intro: This course is designed to help software development teams learn the basics of functional programming and its benefits. We will explore the fundamentals of the functional paradigm in a series of hands-on exercises, which will provide a starting point for your journey into functional programming.
    clean-code-headline-one: The contents of the course are language agnostic, so teams should be able to apply this knowledge to any functional programming language.
    learning-objectives-title: "This course teaches software development teams how to:"
    learning-objectives-list:
      - Introduce the way of thinking of Functional Programming
      - Understand the benefits (and drawbacks) of immutability
      - start using the basic elements needed to create complex applications using FP languages
      - simplify their testing needs
      - introduce some of the ideas into their current paradigms
      - introduce FP languages into their current systems

  audience:
    intro: "This course is designed for software development teams that:"
    list:
      - Have at least two years of commercial experience
      - Are evaluating the use of an FP language
      - Want to simplify the business flows wihtin their system(s)

  course-content:
    list:
      - Lesson 1 - Introduction to course, objectives, F# and Fable
      - Lesson 2 - Introduction to the domain
      - Lesson 3 - Immutability
      - Lesson 4 - Impure/Pure/Impure sandwich
      - Lesson 5 - Functions as first class citizen
      - Lesson 6 - Partial application
      - Lesson 7 - Lambdas
      - Lesson 8 - Piping
      - Lesson 9 - Composition
      - Lesson 10 - Recursion
      - Lesson 11 - Alternatives to recursion
      - Lesson 12 - Pattern Matching
      - Lesson 13 - Helpful Constructs
      - Lesson 14 - Railway Oriented Programming
      - Lesson 15 - Testing
      - Lesson 16 - An overview of FP languages

  prerequisites:
    required: "Required:"
    list:
      - Access to a GitLab account
      - Bring their own laptop
      - "The following applications are installed:"
      - Have an integrated development environment that can handle F#. We recommend using Visual Studio Code with Ionide.
    second-list:
      - NodeJS
      - npm
      - .NET
      - paket - execute `dotnet tool install -g paket` from the command line


lambdas:
  why-attend:
    intro: This course will provide your teams with the theory and motivations behind microservices along with the hands-on experience building them using an AWS serverless architecture.
    learning-objectives-title: "This course teaches software development teams how to:"
    learning-objectives-list:
      - Understand what kind of problems microservices based architecture is trying to solve and the challenges it presents
      - Understand AWS products for building microservices
      - Learn how to build and deploy microservices using the AWS serverless architecture

  audience:
    intro: "This course is designed for software development teams that:"
    list:
      - Have an interest in DevOps culture and microservices
      - Need practical knowledge and techniques using AWS serverless architecture

  course-content:
    principles-intro: What problems are microservices trying to solve?
    list:
      - Microservices best practices
      - Microservices security
      - Anatomy and limitations of AWS Lambda
      - Build a microservice with AWS Lambda, API Gateway, and Dynamo DB
      - Deploy a microservice on the AWS infrastructure
      - Build REST endpoints using API Gateway and AWS Lambda

  prerequisites:
    required: "Required:"
    list:
      - Bring their own laptop
      - Linux VM installed if working from a windows laptop
      - Proficient with a JVM language such as Java, Clojure, Scala or Groovy, Node.js or Python


serverless:
  why-attend:
    intro: Building your Web Application is complicated enough. You don't want to build the infrastructure as well. Cloud based infrastructure such as AWS gives you a tried and tested deployment platform so you can concentrate on the business. This course will give you hands-on experience of how to build fully scalable, reliable and secure web apps using the AWS serverless architecture.
    learning-objectives-title: "This course teaches software development teams how to:"
    learning-objectives-list:
      - Build web apps using AWS serverless architecture
      - Adhere to the AWS well architected framework
      - Understand the significance of the various AWS products within this type of architecture

  audience:
    intro: "This course is designed for software development teams that:"
    list:
      - Want to build secure, reliable, and scalable web applications using the AWS serverless architecture

  course-content:
    list:
      - Build scalable REST APIs using API Gateway and AWS Lambda
      - Build scalable persistence using RDS with automated backups
      - Secure using IAM, KMS, AWS WAF, Json Web Token, and SSL
      - Monitor using Cloud Trail and Cloud Watch
      - Serve static content using S3
      - Deploy using AWS CLI

  prerequisites:
    required: "Required:"
    list:
      - Bring their own laptop
      - Linux VM installed if working from a windows laptop
      - Have an integrated development environment installed
      - Proficient with a JVM language such as Java, Clojure, Scala or Groovy, Node.js or Python

ead:
  why-attend:
    intro: In most enterprise projects the day-to-day development effort does not require the developer to get to know the system as a whole along with the build and deployment tools that support the software development lifecycle. This often results in a lack of knowledge and confidence in the overall system, and the leading approaches in enterprise software development.
    learning-objectives-title: "Learning Outcomes:"
    learning-objectives-list:
      - Create a walking skeleton of the project
      - Create automated system tests
      - Use leading techniques to develop Web Services, Messaging, and Persistence
      - Isolate the business from infrastructure using ports and adapters and Domain Driven Design

  audience:
    intro: "This course is designed for software development teams that:"
    list:
      - Have experience working on Java based Enterprise Systems

  course-content:
    list:
      - Create a build using Maven
      - Add static analysis to your build
      - Create automated system tests using a BDD framework
      - Persistence to a relational store
      - Messaging with JMS
      - RESTful web services
      - Authentication and Authorization
      - XML Marshalling

  prerequisites:
    required: "Required:"
    list:
      - Bring their own laptop
      - "Have an integrated development environment consisting of:"
      - Proficient with a JVM language such as Java, Clojure, Scala or Groovy, Node.js or Python
    second-list:
      - Java 1.7 or above
      - Maven 3.x
