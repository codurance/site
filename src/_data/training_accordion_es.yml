panels:
  - id: por-que-asistir
    title: ¿Por qué asistir?
    content: training_content_why_attend.liquid
  - id: audiencia
    title: Audiencia
    content: training_content_audience.liquid
  - id: contenido-del-curso
    title: Contenido del curso
    content: training_content_course_content.liquid
  - id: prerequisitos
    title: Prerequisitos
    content: training_content_prerequisites.liquid

crafting-code-and-crafted-design:
  why-attend:
    intro: Software Craftsmanship es el corazón de este curso. A lo largo de este curso, tu equipo aprenderá sobre la mentalidad de Software Craftsmanship y cómo aplicarla dentro de la organización.
    clean-code-headline-one: Escribir Clean Code no es fácil; y limpiar código existente todavía menos.
    why-attend: "Tu equipo debe asistir si necesita:"
    why-attend-list:
      - Alinear la tecnología con los requerimientos del negocio
      - Escribir código limpio que sea fácil de entender y mantener
      - "Mejorar sus competencias en Test-Driven Development (TDD): usando testing para diseñar y construir"
    clean-code-headline-two: El código limpio requiere un buen diseño.
    learning-objectives-title: "Tu equipo aprenderá:"
    learning-objectives-list:
      - A comprender los principios de diseño que conducen a un código limpio
      - A evitar la sobre-ingeniería y las grandes reescrituras mediante un diseño que evolucione gradualmente utilizando pruebas
    learning-outcome: Una vez que tu equipo domine estos principios podrá aplicarlos a código heredado. Esto les permitirá ganar confianza trabajando con legacy code.
    software-design-intro: La parte de diseño de software de esta serie de capacitación se centra al nivel de aplicaciones y microservicios utilizando los requisitos comerciales para impulsar el diseño.
    application-title: "Aplicaciones:"
    application-list:
      - estructura interna
      - capas
      - componentes
      - mecanismo de entrega
      - core domain
    microservices-title: "Microservicios:"
    microservices-list:
      - definir la responsabilidad de cada servicio
      - cómo colaboran los servicios
      - visibilidad interna / externa

  audience:
    intro: "Este curso está diseñado para equipos de desarrollo de software:"
    list:
      - familiarizados con un nivel mínimo de lenguaje orientado a objetos
      - con competencias en Java o C#
      - capaces de escribir y ejecutar pruebas unitarias utilizando un framework (como JUnit, NUnit, etc.)
      - con un comprensión básica de los  mock objects

  course-content:
    principles-intro: "Principios de:"
    list:
      - Test-Driven Development (TDD)
      - Object-Oriented Design (OOD)
      - Domain-Driven Design (DDD)
      - Interaction-Driven Design (IDD)
    content-intro: "Contenido:"
    second-list:
      - Ciclo de vida TDD y modelado de comportamientos
      - Escritura de pruebas unitarias que expresan intención, no implementación
      - Utilizando pruebas unitarias para conseguir un buen diseño
      - Expressive code
      - Probar y refactorizar código heredado
      - Cómo estructurar proyectos para que expresen lo que hace la aplicación y de qué se trata
      - Comprender las diferencias entre capas, hexágonos, características y componentes
      - Identificación de servicios a partir de reglas comerciales
      - Expresar diseño y arquitectura en código, pero manteniendo claridad en el dominio
      - Comprender Impact Mapping como técnica y cómo se puede derivar una arquitectura de servicios a partir de ella

  prerequisites:
    intro: Se trata de un curso totalmente práctico, así que se requerirá que los equipos de desarrollo de software escriban mucho código.
    required: "Necesario:"
    list:
      - Tener disponible tu propio ordenador portátil
      - Ser capaz de crear proyectos, construir código fuente y ejecutar casos de prueba en su entorno de desarrollo
      - "Tener un entorno de desarrollo que conste de lo siguiente:"
      - Se recomienda un sistema de control de versiones distribuido como por ejemplo Github
    second-list:
      - Lenguaje orientado a objetos
      - Un framework the unit testing
      - Una librería para hacer mocking


crafting-code:
  why-attend:
    intro: Software Craftsmanship es el corazón de este curso. A lo largo de este curso, tu equipo aprenderá sobre la mentalidad de Software Craftsmanship y cómo aplicarla dentro de la organización.
    clean-code-headline-one: Escribir Clean Code no es fácil; y limpiar código existente todavía menos.
    why-attend: "Tu equipo debe asistir si necesita:"
    why-attend-list:
      - Alinear la tecnología con los requerimientos del negocio
      - Escribir código limpio que sea fácil de entender y mantener
      - "Mejorar sus competencias en Test-Driven Development (TDD): usando testing para diseñar y construir"
    clean-code-headline-two: El código limpio requiere un buen diseño.
    learning-objectives-title: "Tu equipo aprenderá:"
    learning-objectives-list:
      - A comprender los principios de diseño que conducen a un código limpio
      - A evitar la sobre-ingeniería y las grandes reescrituras mediante un diseño que evolucione gradualmente utilizando pruebas
    learning-outcome: Una vez que tu equipo domine estos principios podrá aplicarlos a código heredado. Esto les permitirá ganar confianza trabajando con legacy code.

  audience:
    intro: "Este curso está diseñado para equipos de desarrollo de software:"
    list:
      - Familiarizados con un nivel mínimo de lenguaje orientado a objetos como Java, C# o C++
      - Con competencias en Java o C#
      - Capaces de escribir y ejecutar pruebas unitarias utilizando un framework (como JUnit, NUnit, etc.)
      - Con una comprensión básica sobre mocking

  course-content:
    principles-intro: "Principios de:"
    list:
      - Test-Driven Design (TDD)
      - Object-Oriented Design (OOO)
      - Domain-Driven Design (DDD)
    content-intro: "Contenido:"
    second-list:
      - Ciclo de vida TDD
      - Estilo Outside-IN de TDD
      - Escribiendo unit test que expresan intención, no implementación
      - Utilizando unit test como herramienta para impulsar un buen diseño
      - Expressive code
      - Testing y refactoring de legacy code

  prerequisites:
    intro: Se trata de un curso totalmente práctico, así que se requerirá que los equipos de desarrollo de software escriban mucho código.
    required: "Necesario:"
    list:
      - Tener disponible tu propio ordenador portátil
      - Ser capaz de crear proyectos, compilar código fuente y ejecutar casos de prueba en tu entorno de desarrollo
      - "Tener un entorno de desarrollo que conste de lo siguiente:"
      - Se recomienda un sistema de control de versiones distribuido como por ejemplo Github
    second-list:
      - Lenguaje orientado a objetos
      - Un framework de unit testing
      - Una librería para hacer mocking


crafted-design:
  why-attend:
    intro: Este curso aborda el diseño desde un nivel micro hasta microservicios utilizando Test-Driven Development. Con esta formación los equipos podrán mejorar su capacidad para diseñar software que responda, tanto a las necesidades a menudo muy variables del negocio, como a requsitos nuevos que se planteen, solventando  dificultades derivadas de legacy code.
    learning-objectives-title: "Este curso aporta a los equipos de desarrollo de software conocimientos sobre:"
    learning-objectives-list:
      - Técnicas de diseño que se pueden aplicar a situaciones del mundo real
      - Aplicar arquitectura de microservicios para dar respuesta a las necesidades del negocio
      - Cómo mantener un diseño limpio a medida que la aplicación crece y los requisitos comerciales cambian
      - Construir software que es independiente de la tecnología
      - Comportamiento del modelo en lugar de estado manteniendo un diseño alineado con los objetivos del negocio

  audience:
    intro: "Este curso está pensado para equipos de desarrollo de software que:"
    list:
      - Cuenten con al menos dos años de experiencia en desarrollo de software con fines comerciales
      - Estén familiriarizados con algún lenguaje orientado a objetos, como Java, C# o C++
      - Se sientan cómodos usando TDD para construir software
      - Entiendan mock objects y cómo utlizar una mocking library
      - Tengan una comprensión general de los diferentes estilos arquitectónicos, incluidos los microservicios

  course-content:
    principles-intro: "Principios de:"
    list:
      - Los dos estilos principales de diseño Test-Driven Design (Classicist and Outside-In)
      - Object-Oriented Design (OOO)
      - Domain-Driven Design (DDD)
      - Interaction-Driven Design (IDD)
      - Balanced Abstraction Principle (BAP)
    content-intro: "Contenido:"
    second-list:
      - Escritura de pruebas unitarias que expresan intención, no implementación
      - Diseño emergente a través del TDD Classicist
      - TDD como herramienta de diseño Outside-In style
      - Comandos, consultas y cumplimiento de Open/Close Principle
      - Diferencias entre capas, hexágonos, características y componentes
      - Estructurar proyectos para que expresen lo que hace la aplicación y de qué se trata
      - Comportamiento de modelado utilizando Outside-In Design
      - Identificación de servicios a partir de reglas de negocio
      - Expressive design y arquitectura en código manteniendo su dominio claro
      - Comprender Impact Mapping y cómo derivar hacia una arquitectura de servicios a partir de él

  prerequisites:
    intro: Recomendamos encarecidamente que los equipos de desarrollo de software realicen primero el curso sobre Crafting Code para aprovechar mejor los contenidos de este curso. No se trata de un curso introductorio a Test-Driven Development  y sin una comprensión sólida pueden tener dificultades para seguirlo.
    required: "Necesario:"
    list:
      - Tener disponible tu propio ordenador portátil
      - Aplicar habitualmente TDD  en proyectos
      - Capacidad para crear proyectos, pruebas y códigos y ejecutarlos en su entorno local
      - Se recomienda un sistema de control de versiones distribuido como por ejemplo Github


functional-programming:
  why-attend:
    intro: Este curso está diseñado para ayudar a los equipos de desarrollo de software a aprender los conceptos básicos de la programación funcional y sus beneficios. Exploraremos los fundamentos del paradigma funcional en una serie de ejercicios prácticos, que proporcionarán un punto de partida para iniciarse en la programación funcional.
    clean-code-headline-one: Los contenidos del curso son independientes del lenguaje, por lo que los equipos deberían poder aplicar este conocimiento a cualquier lenguaje de programación funcional. El código no necesariamente será idiomático del lenguaje que estamos usando (F# transpiled to JS with Fable). Pasaremos de tener un código muy básico dentro del dominio (comenzando con un círculo en la pantalla) a mostrar cómo el código podría reescribirse de manera incremental hacia un proceso más funcional. Posteriormente agregaremos múltiples círculos para aumentar la diversión y las posibilidades.
    learning-objectives-title: "Este curso aporya a los equipos de desarrollo de software conocimientos sobre cómo:"
    learning-objectives-list:
      - Introducir la forma de pensar en la programación funcional
      - Comprender los beneficios (y los inconvenientes) de la inmutabilidad
      - Empezar a utilizar los elementos básicos necesarios para crear aplicaciones complejas utilizando lenguajes FP
      - Simplificar sus necesidades de testing
      - Introducir algunas de las ideas en sus paradigmas actuales
      - Introducir lenguajes FP en sus sistemas actuales

  audience:
    intro: "Este curso está pensado para equipos de desarrollo de software que:"
    list:
      - Sus miembros cuenten al menos un par de años de experiencia
      - Estén evaluando el uso de un lenguaje FP
      - Quieran simplificar algunos de los flujos de negocio en sus sistemas

  course-content:
    list:
      - Lección 1 - Introducción al curso, objetivos, F# y Fable
      - Lección 2 - Introducción al dominio
      - Lección 3 - Inmutabilidad
      - Lección 4 - Impure/Pure/Impure sandwich
      - Lección 5 - Funciones como first class citizen
      - Lección 6 - Aplicación parcial
      - Lección 7 - Lambdas
      - Lección 8 - Piping
      - Lección 9 - Composición
      - Lección 10 - Recursión
      - Lección 11 - Alternativas a la recursividad
      - Lección 12 - Pattern Matching
      - Lección 13 - Helpful Constructs
      - Lección 14 - Programación Railway Oriented
      - Lección 15 - Testing
      - Lección 16 - Una visión general de los lenguajes FP

  prerequisites:
    required: "Necesario:"
    list:
      - Acceso a una cuenta de GitLab
      - Tener disponible tu propio ordenador portátil
      - "Instaladas las siguientes aplicaciones:"
      - Tener un entorno de desarrollo integrado que pueda manejar F#. Recomendamos usar Visual Studio Code con Ionide
    second-list:
      - NodeJS
      - npm
      - .NET
      - paket - execute `dotnet tool install -g paket`  desde la línea de comando


lambdas:
  why-attend:
  intro: Este curso proporcionará a tus equipos la teoría y las motivaciones que hay detrás de la aplicación de microservicios junto con la experiencia práctica de construirlos utilizando una arquitectura serverless de AWS.
  learning-objectives-title: "Este curso aporya a los equipos de desarrollo de software conocimientos sobre cómo:"
  learning-objectives-list:
    - Entender qué tipo de problemas está tratando de resolver la arquitectura basada en microservicios y los desafíos que presenta
    - Comprender los productos de AWS para crear microservicios
    - Aprender a construir e implementar microservicios utilizando la arquitectura serverless de AWS

  audience:
    intro: "Este curso está pensado para equipos de desarrollo de software que:"
    list:
      - Tengan interés en la cultura DevOps y los microservicios.
      - Quieran adquirir los conocimientos prácticos y técnicas que utilizan la arquitectura serverless de AWS."

  course-content:
    principles-intro: ¿Qué problemas están tratando de resolver los microservicios?
    list:
      - Best practices en microservicios
      - Anatomía y limitaciones de AWS Lambda
      - Construye un microservicio con AWS Lambda, API Gateway y Dynamo DB
      - Implementa tu microservicio en la infraestructura de AWS desde la línea de comandos
      - Asegura tu microservicio
      - Creación de REST endpoints con API Gateway y AWS Lambda

  prerequisites:
    required: "Necesario:"
    list:
      - Tener disponible tu propio ordenador portátil
      - Linux VM instalado si se trabaja desde un ordenador con Windows
      - Nivel elevado con un lenguaje JVM como Java, Clojure, Scala o Groovy, Node.js o Python


serverless:
  why-attend:
    intro: Construir su aplicación web es bastante complicado, pero no tiene porque ser necesario construir la infraestructura también. La infraestructura basada en cloud como AWS ofrece una plataforma de implementación probada que te permitirá poner el foco en las necesiades del negocio. Este curso te ofrece los conocimientos prácticos necesarios sobre cómo crear aplicaciones web totalmente escalables, confiables y seguras utilizando la arquitectura serverless de AWS.
    learning-objectives-title: "Este curso aporta a los equipos de desarrollo de software conocimientos sobre cómo:"
    learning-objectives-list:
      - Construir aplicaciones web con la arquitectura serverless de AWS.
      - Adoptar AWS Well Architected Framework.
      - Comprender la importancia de los diversos productos de AWS dentro de este tipo de arquitectura.

  audience:
    intro: "Este curso está diseñado para equipos de desarrollo de software que:"
    list:
      - Necesiten crear aplicaciones web seguras, confiables y escalables utilizando la arquitectura serverless de Amazon

  course-content:
    list:
      - Construye API REST escalables con API Gateway y AWS Lambda
      - Construye persistencia escalable utilizando RDS con copias de seguridad automatizadas
      - Consigue seguridad utilizando IAM, KMS, AWS WAF, Json Web Token y SSL
      - Monitoriza usando Cloud Trail y Cloud Watch
      - Ofrece contenido estático utilizando S3
      - Deploy con AWS CLI

  prerequisites:
    required: "Necesario:"
    list:
      - Tener disponible tu propio ordenador portátil
      - Linux VM instalado si trabajas desde un ordenador con Windows
      - Tener instalado un entorno de desarrollo integrado
      - Nivel elevado con un lenguaje JVM como Java, Clojure, Scala o Groovy, Node.js o Python